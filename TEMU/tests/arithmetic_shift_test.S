# 目标：测试C任务实现的6条指令 add, addu, addiu, sll, srav, lui
# 全面测试各种情况，包括正常情况、边界情况、溢出情况

#include "trap.h"
.set noat
.text
.globl main

main:
    # ==========================================
    # 测试1: LUI - 加载立即数到高16位
    # ==========================================
    # LUI rt, imm: GPR[rt] = (imm << 16) | 0
    lui $t0, 0x1234              # $t0 = 0x12340000
    lui $t1, 0xFFFF              # $t1 = 0xFFFF0000 (测试最大值)
    lui $t2, 0x0000              # $t2 = 0x00000000 (测试最小值)
    lui $t3, 0x8000              # $t3 = 0x80000000 (测试符号位)
    # 预期结果: $t0=0x12340000, $t1=0xFFFF0000, $t2=0x00000000, $t3=0x80000000
    
    # ==========================================
    # 测试2: ADDIU - 立即数加法（符号扩展）
    # ==========================================
    # ADDIU rt, rs, imm: GPR[rt] = GPR[rs] + sign_extend(imm)
    ori $s0, $zero, 100          # $s0 = 100
    addiu $s1, $s0, 50           # $s1 = 100 + 50 = 150 (正数立即数)
    addiu $s2, $s0, -30          # $s2 = 100 + (-30) = 70 (负数立即数，符号扩展)
    addiu $s3, $zero, 0xFFFF     # $s3 = 0 + (-1) = 0xFFFFFFFF (0xFFFF符号扩展为-1)
    addiu $s4, $zero, 0x7FFF     # $s4 = 0 + 32767 = 0x00007FFF (最大正立即数)
    addiu $s5, $zero, 0x8000     # $s5 = 0 + (-32768) = 0xFFFF8000 (最小负立即数)
    # 预期结果: $s1=150, $s2=70, $s3=0xFFFFFFFF, $s4=0x00007FFF, $s5=0xFFFF8000
    
    # ==========================================
    # 测试3: ADDU - 无符号加法（不检测溢出）
    # ==========================================
    # ADDU rd, rs, rt: GPR[rd] = GPR[rs] + GPR[rt] (无符号，不检测溢出)
    lui $a0, 0x7FFF              # $a0 高16位 = 0x7FFF
    ori $a0, $a0, 0xFFFF         # $a0 = 0x7FFFFFFF (最大正数)
    ori $a1, $zero, 1            # $a1 = 1
    addu $a2, $a0, $a1           # $a2 = 0x7FFFFFFF + 1 = 0x80000000 (溢出但不报错)
    lui $a3, 0xFFFF              # $a3 高16位 = 0xFFFF
    ori $a3, $a3, 0xFFFF         # $a3 = 0xFFFFFFFF
    addu $t0, $a3, $a1           # $t0 = 0xFFFFFFFF + 1 = 0x00000000 (无符号溢出)
    ori $t1, $zero, 100          # $t1 = 100
    ori $t2, $zero, 200          # $t2 = 200
    addu $t3, $t1, $t2           # $t3 = 100 + 200 = 300
    # 预期结果: $a2=0x80000000, $t0=0x00000000, $t3=300
    
    # ==========================================
    # 测试4: ADD - 有符号加法（检测溢出）
    # ==========================================
    # ADD rd, rs, rt: GPR[rd] = GPR[rs] + GPR[rt] (有符号，检测溢出)
    # 注意：溢出时会触发异常，所以先测试正常情况
    ori $v0, $zero, 100          # $v0 = 100
    ori $v1, $zero, 200          # $v1 = 200
    add $t4, $v0, $v1            # $t4 = 100 + 200 = 300 (正常情况)
    lui $t5, 0x7FFF              # $t5 高16位 = 0x7FFF
    ori $t5, $t5, 0xFFFF         # $t5 = 0x7FFFFFFF (2147483647)
    ori $t6, $zero, 0            # $t6 = 0
    add $t7, $t5, $t6            # $t7 = 0x7FFFFFFF + 0 = 0x7FFFFFFF (正常)
    # 预期结果: $t4=300, $t7=0x7FFFFFFF
    # 溢出测试在下面单独进行，因为会触发异常
    
    # ==========================================
    # 测试5: SLL - 逻辑左移
    # ==========================================
    # SLL rd, rt, sa: GPR[rd] = GPR[rt] << sa
    ori $s6, $zero, 0x00000001   # $s6 = 1
    sll $s7, $s6, 1              # $s7 = 1 << 1 = 2
    sll $t8, $s6, 31             # $t8 = 1 << 31 = 0x80000000 (移31位)
    ori $t9, $zero, 0x0000000F   # $t9 = 15 (0xF)
    sll $k0, $t9, 4              # $k0 = 15 << 4 = 240 (0xF0)
    sll $k1, $t9, 0              # $k1 = 15 << 0 = 15 (不移位)
    lui $gp, 0x8000              # $gp = 0x80000000
    sll $sp, $gp, 1              # $sp = 0x80000000 << 1 = 0x00000000 (溢出)
    # 预期结果: $s7=2, $t8=0x80000000, $k0=240, $k1=15, $sp=0x00000000
    
    # ==========================================
    # 测试6: SRAV - 算术右移（使用寄存器值作为移位量）
    # ==========================================
    # SRAV rd, rt, rs: GPR[rd] = GPR[rt] >> (GPR[rs] & 0x1F) (算术右移)
    # 注意：使用 $t0-$t3 存储结果，避免与之前使用的寄存器冲突
    # 测试负数算术右移（保持符号位）
    ori $at, $zero, 8            # $at = 8 (移位量)
    lui $fp, 0x8000              # $fp = 0x80000000 (负数)
    srav $t0, $fp, $at           # $t0 = 0x80000000 >> 8 = 0xFF800000 (保持符号位)
    
    # 测试正数算术右移
    ori $at, $zero, 4            # $at = 4 (移位量)
    ori $fp, $zero, 0x8000       # $fp = 32768 (正数，0x00008000)
    srav $t1, $fp, $at           # $t1 = 0x00008000 >> 4 = 0x00000800
    
    # 测试大移位量（只取低5位）
    ori $at, $zero, 0x0023       # $at = 35, 但只取低5位 = 3
    ori $fp, $zero, 0x00F0       # $fp = 240
    srav $t2, $fp, $at           # $t2 = 240 >> 3 = 30
    
    # 测试负数算术右移（保持符号位）
    ori $at, $zero, 2            # $at = 2
    lui $fp, 0xFFFF              # $fp 高16位 = 0xFFFF
    ori $fp, $fp, 0xFFF0         # $fp = 0xFFFFFFF0 (-16的补码)
    srav $t3, $fp, $at           # $t3 = -16 >> 2 = -4 = 0xFFFFFFFC
    
    # 测试移0位（使用 $k0，因为 $t0-$t3 已经被使用）
    ori $at, $zero, 0            # $at = 0
    lui $fp, 0x1234              # $fp 高16位 = 0x1234
    ori $fp, $fp, 0x5678         # $fp = 0x12345678
    srav $k0, $fp, $at           # $k0 = 0x12345678 >> 0 = 0x12345678
    # 预期结果: $t0=0xFF800000, $t1=0x00000800, $t2=30, $t3=0xFFFFFFFC, $k0=0x12345678
    
    # ==========================================
    # 综合测试：组合使用多条指令
    # ==========================================
    # 使用 lui + addiu 构造32位立即数
    lui $s0, 0x1234              # $s0 = 0x12340000
    addiu $s0, $s0, 0x5678       # $s0 = 0x12340000 + 0x5678 = 0x12345678
    
    # 使用 addu 进行地址计算
    lui $s1, 0x8000              # $s1 = 0x80000000
    ori $s2, $zero, 0x1000       # $s2 = 0x1000
    addu $s3, $s1, $s2           # $s3 = 0x80001000 (地址计算)
    
    # 使用 sll 进行乘法（乘以4）
    ori $s4, $zero, 100          # $s4 = 100
    sll $s5, $s4, 2              # $s5 = 100 << 2 = 400 (相当于 100 * 4)
    
    # 使用 add 进行有符号加法
    ori $s6, $zero, 50           # $s6 = 50
    add $s7, $s4, $s6            # $s7 = 100 + 50 = 150
    
    # 预期结果: $s0=0x12345678, $s3=0x80001000, $s5=400, $s7=150
    
    # ==========================================
    # 测试完成标记
    # ==========================================
    # 如果运行到这里，说明所有非溢出测试都通过了
    ori $v0, $zero, 1            # $v0 = 1 表示成功
    HIT_GOOD_TRAP

    # ==========================================
    # 溢出测试（单独测试，因为会触发异常）
    # ==========================================
    # 注意：这些测试会导致程序异常终止，所以放在最后
    # 如果需要测试溢出，可以单独运行以下代码：
    #
    # overflow_test:
    #     # 测试正溢出: 0x7FFFFFFF + 1
    #     ori $t0, $zero, 0x7FFFFFFF
    #     ori $t1, $zero, 1
    #     add $t2, $t0, $t1       # 应该触发溢出异常
    #
    #     # 测试负溢出: 0x80000000 + (-1)
    #     ori $t3, $zero, 0x80000000
    #     ori $t4, $zero, 0xFFFFFFFF  # -1
    #     add $t5, $t3, $t4       # 应该触发溢出异常

